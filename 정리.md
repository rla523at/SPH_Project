# SPH Frame Work
SPH approximation에 의해 임의의 물리량 $f$에 대한 근사식은 다음과 같다.

$$ f(x) = \sum_j \frac{m_j}{\rho_j}f(x_j) W(x-x_j,h) $$

이 approximation을 통해 비압축성 유체의 linear momentum equation을 푼다.

$$ \frac{du}{dt} = -\frac{1}{\rho}\nabla p + \nu \nabla^2u + f_{ext} $$

전체적인 solution prcess는 다음과 같다.

1. SPH approximation을 통해 $\rho$를 계산한다.
2. 계산된 $\rho$를 통해 $p$를 계산한다.
3. SPH approximation를 활용해 linear momentum equation의 RHS를 계산한다.
4. 계산된 가속도로 속도를 업데이트하고, 속도로 위치를 업데이트한다.

</br></br>

# SPH Approximation
## Integral Representation
임의의 $f:\mathbb{R}^3\rightarrow \mathbb{R}$가 있을 떄, 임의의 $x \in \Omega \subseteq \mathbb{R}^3$에 대해서 다음이 성립한다.

$$ f(x) = \int_{\Omega} f(t)\delta(x-t)dt $$

$\delta$는 dirac-delta function kernel이다.

## Approximation of Integral Representation
$\delta$를 임의의 smooth kernel function $W(x,h):\mathbb{R}^3 \rightarrow \mathbb{R}$로 근사하면 다음과 같다.

$$ f(x) \approx \int_{\Omega} f(t)W(x-t, h)dt $$

이처럼, $\delta$를 임의의 smooth function으로 approximation을 하기 때문에 'smoothed' particle hydronamics라고 한다.

## Particle Approximation
$W$를 이용한 Integral Representation의 approximation은 discretized form으로 한번 더 근사가 될 수 있다.

$$ \begin{aligned} 
f(x) &\approx \int_{\Omega} f(t)W(x-t, h)dt \\ 
     &\approx \sum_{j} f(x_j)W(x-x_j,h) \Delta V_j \\ 
     & = \sum_{j} f(x_j)W(x-x_j,h) \frac{\rho_j \Delta V_j}{\rho_j} \\ 
     &= \sum_{j} f(x_j)W(x-x_j,h) \frac{m_j}{\rho_j} 
\end{aligned}  $$

따라서, SPH frame work상 임의의 물리량 $f$에 대한 최종 근사식은 다음과 같다.

$$ f(x) = \sum_j \frac{m_j}{\rho_j}f(x_j) W(x-x_j,h) $$

</br></br>

# Smooth Kernel Function
$W(x,h)$는 $\delta$를 근사한 함수이기 때문에 다음 세가지 조건을 만족해야한다.

Normalization condition

$$ \int_\Omega W(x-t,h)dt = 1$$

Delta Function Property

$$ \lim_{h\rightarrow 0} W(x-t,h) = \delta(x-t)$$

Compact Supprot Property

$$ \kappa h < |x-t| \implies W(x-t,h) = 0 $$

따라서, $h$에 의해 $W$의 compact support domain이 결정되며, $h$를 support length라고 한다.

![support length](https://github.com/user-attachments/assets/788aa774-2b4f-4b4c-a260-6a9b29e40c33)

</br></br>

# Density Calculation
SPH 근사식에 밀도를 대입하면 다음과 같다.

$$ \rho(x) = \sum_j m_jW(x,x_j,h) $$

비압축성 유체이기 때문에 $m_j$가 일정하다고 가정하면 밀도는 오직 거리의 함수이다. 

밀도는 pressure calculation과 비압축성 가정 $(\frac{\Delta\rho}{\rho_0})^2 \sim (M \le 0.1)$에 의해 다음 범위의 값을 갖는것이 타당하다.

$$ \rho_0 \le \rho \le 1.01 \rho_0 $$

밀도 값에 영향을 주는 값들은 $m$ 그리고 $W$ 값이다.

이 때, $W$의 값은 $h$를 어떻게 결정하냐에 따라 크게 달라진다.

## smoothing length
3차원 기준 neighbor가 50개가 되도록 잡는게 좋다.

> Reference  
> https://scicomp.stackexchange.com/questions/16363/how-to-choose-h-in-sph  

</br></br>

# Pressure Calculation
압력은 Equation of state에 기반하여 수정한 다음 식을 사용한다.

$$ p = k ((\frac{\rho}{\rho_0})^7 - 1) $$

$\rho_0$는 rest density로 유체가 기본 상태에 있을 때의 밀도를 나타낸다.

$k$는 stiffness constant로 큰 값을 쓸 수록, compressibility는 줄어들지만 (밀도 변화는 줄어들지만) time step 또한 줄어든다.

참고로, 위 식에서 $\rho < \rho_0$인 경우 $p<0$가 된다. 압력이 음수가 되는 것은 비물리적임으로 밀도가 $\rho_0$ 항상 커야 한다.

</br></br>

# Acceleration by Pressure
압력에 의한 가속도는 다음과 같다.

$$ a_p(x_i) = -\frac{1}{\rho_i}\nabla p_i $$

근사한 물리량의 미분을 구할 때 SPH discretization formular를 바로 미분해서 사용하면 simulation이 unstable 해지는 현상이 있기 때문에 discrete differential operator를 사용한다.

$$ \nabla A_i \approx \rho_i \sum_j m_j (\frac{A_i}{\rho_i^2} + \frac{A_j}{\rho_j^2}) \nabla W_{ij} $$

위의 discrete differential operator를 사용하고 $m$이 모든 particle에서 $m_0$로 일정하다고 가정하면 다음과 같이 표현할 수 있다.

$$ a_p(x_i) = - m_0 \sum_j (\frac{p_i}{\rho_i^2} + \frac{p_j}{\rho_j^2}) \nabla W_{ij} $$

$a_p$의 방향은 $\sum_j -\nabla_iW_{ij}$이다.

> Reference  
> 2022 (Dan et al) A Survey on SPH Methods in Computer Graphics - 2.5 - symmetric formula  

</br></br>

# Acceleration by Viscosity
점성에 의한 가속도는 다음과 같다.

$$ a_v(x_i) = \nu \nabla^2u $$

근사한 물리량의 미분을 구할 때 SPH discretization formular를 바로 미분해서 사용하면 simulation이 unstable 해지는 현상이 있기 때문에 discrete differential operator를 사용한다.

$$ \nabla^2A_i = 2(d+2)\sum_j \frac{m_j}{\rho_j} \frac{A_{ij} \cdot x_{ij}}{x_{ij} \cdot x_{ij}+0.01h^2} \nabla W_{ij} $$

위의 discrete differential operator를 사용하고 $m$이 모든 particle에서 $m_0$로 일정하다고 가정하면 다음과 같이 표현할 수 있다.

$$ a_v(x_i) = 2 \nu (d+2) m_0 \sum_j \frac{1}{\rho_j} \frac{v_{ij} \cdot x_{ij}}{x_{ij} \cdot x_{ij}+0.01h^2} \nabla W_{ij}  $$

> Reference  
> 2022 (Dan et al) A Survey on SPH Methods in Computer Graphics - 2.5.1  Discretization of the Laplace Operator

---




* Weakly Compressible SPH (WCSPH)
  * local pressure solvers
* Incompressible SPH (ISPH)
  * global pressure solvers


# Smoothing Length
**1996 (Koshizuka & Oka) Moving-Particle Semi-Implicit Method for Fragmentation of Incompressible Fluid**
* IV.B. Calculation Parameters
  * $h = 1.4 - 1.7 \Delta x$
  * $\Delta x$ = initial particle spacing


**1999 (Sharen and Rudman) An SPH Projection Method**
* 2.1. Weakly Compressible SPH
  * $h = 1 - 1.5 \Delta x$
  * $h$ = smoothing length
  * $\Delta x$ = initial particle spacing
* 3. Simulations
  * $h=1.3 \Delta x$
  * $h$ = smoothing length
  * $\Delta x$ = initial particle spacing

**2000 (Joseph) Simulating surface tension with SPH**
* $h = 1 - 1.5 \Delta x$
  * $\Delta x$ = initial particle spacing
 

**2007 (Markus and Matthias) Weakly compressible SPH for free surface flows**
* $h = \Delta x$
* $\Delta x$ = initial particle spacing

**2012 (Mostafa et al) A robust weakly compressible SPH method and its comparison with an incompressible SPH**
* $h = 1.6 \Delta x$
* $\Delta x$ = initial particle spacing

**2014 (Goffin et al) Validation of a SPH Model For Free Surface Flows**
* 2.2 Some Implementation Aspects
  * $h = 1.2\Delta x$
  * $h$ = smoothing length
  * $\Delta x$ = initial particle spacing


**CPP-Fluid-Particles**
* const float sphSmoothingRadius = 2.0f * sphSpacing;
* pSystem = std::make_shared<SPHSystem>(fluidParticles, boundaryParticles, pSolver,
* SPHSystem::SPHSystem
  * _sphSmoothingRadius = sphSmoothingRadius
* SPHSystem::step
* BasicSPHSolver::step
  * radius = sphSmoothingRadius
* static inline __device__ float cubic_spline_kernel(const float r, const float radius)
  * h = 0.5radius

## Smoothing Length에 따른 Stability
Smoothing Length가 줄어들면 solution이 발산한다.

## Smoothing Length에 따른 initial density distribution
$h = \Delta x$일 때, 999, 850, 719, 606의 4가지 density를 갖음.

$h = 1.5\Delta x$일 때, 1001, 977, 953, 929, 735, 716, 697, 537, 523, 392의 가지 density를 갖음.

# Free Surface parameter
**1996 (Koshizuka & Oka) Moving-Particle Semi-Implicit Method for Fragmentation of Incompressible Fluid**
* IV.B. Calculation Parameters
  * $\beta = 0.8 - 0.99$

**2008 (ataie-ashtiani et al) Modified incompressible SPH meothod for simulating free surface problems**
* 4.2 Free surface
* 6.1.1. Density error analysis for the dam-break problem
  * $\beta = 0.8 - 0.99$

**2016 (Shobeyri) A Simplified SPH Method for Simulation of Free Surface Flows**
* 3.2.1 Free Surfaces
  * $\beta = 0.8 - 0.95$

# Number Density
* 1992 (monaghan) Smoothed Particle Hydrodynamics
  * 6 SPATIALLY-VARYING RESOLUTION

# mass
**1992 (monaghan) Smoothed Particle Hydrodynamics - 10.1 The Particle Setup**
* $m_a = \rho \Delta V_a$
* $\Delta V_a$가 뭔지 안알려줌

**1994 (monaghan) Simulating Free Surface Flows with SPH - 5. Implementation**
* $m_b = \rho_b \Delta A$
* $\Delta A$ is the area per particle

**[note] 2011 (cornell)**  
* normalized mass

**2012 (Mostafa et al) A robust weakly compressible SPH method and its comparison with an incompressible SPH**
* number density

**SPlisHSPlasH**
* void FluidModel::initMasses()
* const Real diam = static_cast<Real>(2.0)*particleRadius;
* m_V = static_cast<Real>(0.8) * diam*diam*diam;
  * each particle represents a cube with a side length of r

**[Book] (Violeau) Fluid Mechanics and the SPH Method_ Theory and Applications**
* $V_0 = L^3$
* $L$은 initial interparticular distance

## mass 업데이트
* 중간에 mass 업데이트하면 폭발적으로 변하면서 난리남
* initial condition에서 max로 적용하는게 가장 좋음

# cubic spline Kernel Function
**1992 (monaghan) Smoothed Particle Hydrodynamics**
* kernel based on spline functions

**2010 (Liu and Liu) SPH an overview and recent developments**

**2014 (Markus et al) SPH Fluids in Computer Graphics**

**https://pysph.readthedocs.io/en/latest/reference/kernels.html**

**https://pysph.readthedocs.io/en/latest/_modules/pysph/base/kernels.html#CubicSpline.gradient_h**
* gradient, dwdq

**SPlisHSPlasH**
* class CubicKernel
  * static void setRadius(Real val)
  * m_radius = support_radius
  * h = m_radius
* Simulation::initKernels
  * supprot radius = 4 * particle radius
  * m_k = 8.0 / pi h^3

# Density Calculation
* 1994 (monaghan) Simulating Free Surface Flows with SPH
  * 2. THE SPH EQUATIONS
  * approximate the rate of change of the density

* 2007 (Crespo et al) Boundary Conditions Generated by Dynamic Particles in SPH Methods
  * 2.3 Continuity equation
    * solve continuity equation
    * summation of mass terms, which leads to an artificial density decrease near fluid interfaces

* 2010 (Mocho et al) State-of-the-art of classical SPH for free-surface flows
  * 3.2 Conservation of mass
    * not the best option in fluid calculations since it leads to a density drop near the free surface of the fluid as stated by Monaghan (1992).

* 2012 (Xiaowei et al) Local Poisson SPH For Viscous Incompressible Fluids
  * [RL96] to improve the accuracy near free surface boundaries and material interfaces.
    * 2010 (Mocho et al) State-of-the-art of classical SPH for free-surface flows - 2.6.1.1 Zeroth order – Shepard filter 에 나온것과 같은 형태이다.

* 2014 (Markus et al) SPH Fluids in Computer Graphics
  * 6.1. Liquid-Liquid Interface
    * In the computer graphics literature, the density summation equation is preferred over evolving the density with the continuity equation

* 2014 (Goffin et al) Validation of a SPH Model For Free Surface Flows
  * 2.1 Equations and Smoothing Functions 
    * solve continuity equation

* SPlisHSPlasH
  * TimeStepWCSPH::step
  * TimeStep::computeDensities

* Book Liu & Liu
  * density.f

# Free Surface Boundary Condition
**1996 (Koshizuka & Oka) Moving-Particle Semi-Implicit Method for Fragmentation of Incompressible Fluid**
* III.F. Modeling of Free Surfaces
  * Pressure zero is given to free surface particle as the boundary condition

**2016 (Shobeyri) A Simplified SPH Method for Simulation of Free Surface Flows**
* 3 Governing Equations
  * The Dirichlet boundary condition of zero pressure on free surface


# Tait's Pressure Calculation
**2007 (Markus and Matthias) Weakly compressible SPH for free surface flows**
* $B = \rho_0 V_s^2 / \gamma$ ~ 1.1e06 

**2012 (Mostafa et al) A robust weakly compressible SPH method and its comparison with an incompressible SPH**
* Artificial equation of state WCSPH

# Artificial Viscosity Term
* 2014 (Markus et al) SPH Fluids in Computer Graphics 식이 잘못되어 있음
* 2005 (monaghan) Smoothed Particle Hydrodynamics
* 2022 (Dan et al) A Survey on SPH Methods in Computer Graphics

# Surface Tension
* 2000 (Joseph) Simulating surface tension with SPH

# Position Update
* 2007 (Crespo et al) Boundary Conditions Generated by Dynamic Particles in SPH Methods
  * 2.5 Moving the particles
    * using XSPH variant

* 2010 (Mocho et al) State-of-the-art of classical SPH for free-surface flows
  * 3.6 Moving the particles
    * using XSPH variant

# Tensil Instability
**2000 (monaghan) SPH without a Tensil Instability**

# $\Delta t$
**2009 (solenthaler and Pajarola) Predictive-Corrective Incompressible SPH**
* PCISPH
  * BOundary condition 적용해도 dt에 아무런 영향을 못줌

**2019 (Xi et al) Survey on Smoothed Particle Hydrodynamics and the Particle Systems**
* C. PREDICTIVE-CORRECTIVE INCOMPRESSIBLE SMOOTHED PARTICLE HYDRODYNAMICS (PCISPH)




# Neighborhood Search
## Uniform Grid
**자신이 속한 grid cell을 찾는다.**

grid cell마다 고유의 grid cell index vector $c$를 갖는다.

$$ c = (i,j,k) $$

임의의 particle의 위치를 $x$라고 할 때, $x$가 속한 grid cell의 $c$는 다음과 같다.

$$ c(x) = (\left\lceil \frac{x-x_{min}}{h}  \right\rceil, \left\lceil \frac{y-y_{min}}{h}  \right\rceil, \left\lceil \frac{z-z_{min}}{h}  \right\rceil $$

이 떄, $h$는 정육면체의 길이, $(x_{min},y_{min},z_{min})$는 bounding box의 최소 좌표이다.

정육면체의 한 면을 $h$라고 할 때, $h$가 smoothing length와 같다고 가정하자.

Domain bounding box에 속한 모든 $c$의 집합을 $C$, $x$가 속한 grid cell의 index vector를 $c_x = (i_x,j_x,k_x)$라고 한다면 집합 $N$은 다음과 같다.

$$ N = \{ (i,j,k) | (i_x \pm 1,j_x \pm 1, k_x \pm 1) \in C \} $$

즉, 최대 27개의 grid cell만 탐색하면 된다. 


Domain bounding box가 $x,y,z$ 방향으로 $N_{x,y,z}$개로 나뉘었다고 하자.

그러면 $c$의 고유의 index $c_i$를 다음과 같이 구할 수 있다.

$$ c_i = i + j  N_x + k N_x N_y $$

따라서, grid cell마다 속한 particle을 저장하기 위해서 이중배열이면 충분하다.

## Index Sort
unifrom grid는 동시에 같은 memory에 접근하는 race condition으로 parallel construction이 어렵다.

memory conflict를 피하기 위해 먼저 particle을 cell index로 sorting한다.

## Spatial Hashing



# 테스트
20 * 20 * 20 -> 300FPS
20 * 20 * 20 -> 400FPS (heap allocation 줄이기)
20 * 20 * 20 -> 600FPS (update에서 한번에 처리하기)

10 * 10 * 10 -> 370FPS (기본)
10 * 10 * 10 -> 450FPS (heap allocation 줄이기)
10 * 10 * 10 -> 600FPS (update에서 한번에 처리하기)



# 영상
* https://www.youtube.com/watch?v=uaoT37-NhCE
* https://www.youtube.com/watch?v=7kDVjZkc_TI
* https://www.youtube.com/watch?v=9YxseonuAJ8 (droplet)
